# Terms and Conditions

All good metaphors have terms and conditions and our metaphor of Trigger as Reflex is no exception. The Terms and Conditions of this metaphor give us safe and reasonable boundaries -- to keep us from overwelming the system we all play in. This isn't really a breakdown of the metaphor either. After all, Reflexes don't work *everywhere*. When the Doctor hit me in the forhead with the hammer of doom... well, I didn't kick him a second time.

Likewise, every good platform has its fair share of idiomatic phrases. These phrases come up in the strangest of places, but its best we discuss them before they do come up. Otherwise this becomes a Suesian exercise in:
```
whozits and whatzits all acting on star_bellied_sneeches__c
if their green eggs and ham are true.
```

Lets start off with some terms.
1. You'll hear me say "*Logic*" a few times. Don't worry, depsite what your Professors and teachers have said about it in the past, when you say logic 3 times, the boogey man does not pop into existence right behind you. Logic, workflows, are the process that data goes through of being Read, Evaluated, Caclulated and Saved. I call it the RECS loop. You use these same ideas when creating workflows and approval processes. So, remember this, when I say logic, you say "workflow." Lets try it. Logic! ... Oh come on Chicago, you can do better than that. [Green Bank, WV said "Workflow" with more conviction that that. Hell, they don't even have cell phones there.](http://www.cnet.com/news/allergic-to-wi-fi-move-to-west-virginia/) What do I really mean by all this? Simply that whenever we talk about the "logic" (much better Chicago) of a trigger, we're talking about the ***process*** of reading, evaluating, calculating and saving data that our trigger is going to execute for us as our refelex action.
2. Our second term is Syntax. While there are many definitions of syntax, it's probably best to think of syntax as a fancy college dollar word for ***grammar***. The good news is no one is going to slap your hand with a ruler if you end up getting the grammar wrong. The bad news, is that Apex is like a really fast, really obedient, really stupid dog. Like this one: ![inline](http://i.imgur.com/3E0huIs.jpg) This is my dog Rake, or Captain Syntax as I like to (almost never) call him. He's chubby, loving, obedient and well, not the brightest pup! For instance, if I throw a ball and tell Rake to fetch, he will go (slowly walking) over to the ball, pick it up, and then lay down and chew on it. Technically, Rake has done *exactly* what I asked him to do. I said fetch, not "fetch, and return the ball to me at a speed aproaching exercise". The Apex syntax is similarlly loving and obdedient -- it wants to help you smash through business obstacles like a chainsaw through butter, but you have to be very ***precise*** with what you ask it todo. Don't worry though, remember that whole bit about walking before running. We're going to spend a lot more time on syntax, so ![inline 50%](http://fc03.deviantart.net/fs71/f/2010/201/8/a/DON__T_PANIC_by_tind.jpg)
3. Objects are things. No seriously, they're nouns. It's just that, well, Noun was taken, [so these four dudes from back when you measured experience by beard length](http://en.wikipedia.org/wiki/Design_Patterns) chose the word "object". Go figure. When we say Object, we're talking about the same objects that you create in the UI under create -> object. They have labels, and "api names" with funny __c's after the name. Objects have properties, but Objects aren't ... things unto themselves. No no, you have an...
4. Instance of an Object which we all know and love as a ***record*** of the object. So we can talk about the *Case Object* or creating a *Case Object* but we store ***instances*** of the Case Object as ***Case Records***. I realize this sounds like a pretty fine distinction, and it is, but it's also one of the most fundamental and key distinctions we'll run into.
4. Classes. When we say Class, think Classification, not room full of uncomfortable chairs in a high pressure, weggie filled environment. Classes are code files that describe objects. In our case, they'll be written in Apex, the Salesforce Programming Language.
5. Methods. Remember Simon says? Simon says quack like a duck! ```aflack``` Think of methods as the action that Simon tells us to do. For instance, Simon might ask us to add two numbers together. Or find all the contacts who's last name is "AwesomeSauce". The thing is, when we're writting Triggers, we're Simon. We create our own commands with inputs and expected outputs. They are, in effect, our minions.
7. Types - Ok, so Types are one of those things where computer scientists (For some reason I always imagine horn rimmed glasses and labcoats in an underground bunker with dim light...) decided that the world as it was was blank and formless. And so they divided the world into programming langauges that have types, and those that don't have types, and it was (boolean) good. (That last bit's a joke, which you'll probably get later). Ever since that fateful day fans of both language varieties have been fighting a no-holds-barred tag team wrestling match over which is better. In many ways it's where young programmers go to practice fighting over which is better, Vi or Emacs. For our discussion of types, lets use the analogy of our humble kitchen pantry. Not the OCD pantry of awesomeness that Alton brown has, but your typical suburbanite pantry; Always feels a little small, always has things in it we forgot we ever bought. Why a pantry? because a pantry is a lot like Memory. You can never have enough Memory, and inevitably, your os is like "oh, so
 1. First up are Untyped langauages. In an untyped lanague, your kitchen pantry would look very organic, but ... apoplectic. Imagine if all of your pantry good from the store came in water balloons. 5lbs of flour? in a ballon. 14.5oz of green beans? in a baloon. Kippers? yep... in a balloon. For developers this is really a benefit for productivity. We just have to shove data in a baloon and throw the baloon in our pantry. We don't have to care what Imagine your kitchen pantry. Programming Languages that have types, are like your stereo typical kitchen pantry -- full of a few different *types* of objects, but many of the same types as well. In other words you've got 99 cans of veggies, but no room for a sack of flour. Or maybe you have 3 sacks of flour (one type), 19 cans of veggitables (another type) and 2 boxes of cereal. Each of these (sack, can, box) is analgous to a Type. Types are the memory blueprint for how and what kind of data is stored there. In the computer world, our types are slightly different. Instead of being sacks, cans and boxes, they're things like Integer, Decimal, String and Account.


![inline](http://i.imgur.com/HK3iraZ.jpg)So if you've not caught on yet, the computer programming world is full of renamed everything. I'm honestly surprised we haven't renamed cloud computing to be "High Altitude Mist Holding and Computation Kingdom" or #HAMHOCK. Just watch, it's coming to an ```<big name consulting firm>``` poster near you. #unSafeHarbor.
